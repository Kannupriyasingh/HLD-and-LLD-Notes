# 🌟 High-Level Design (HLD) — Short Notes

## 🪜 Step 1: Fundamentals

* Serverless vs Serverful: pay-per-use vs managed servers.
* Horizontal vs Vertical scaling.
* Threads: lightweight processes.
* Pages: fixed-size memory blocks.
* Internet: DNS → TCP/UDP → HTTP → browser.

## 🛢 Step 2: Databases

* SQL vs NoSQL: ACID vs BASE.
* In-memory DBs: Redis, Memcached.
* Replication & migration.
* Partitioning & sharding.

## ⚖ Step 3: Consistency vs Availability

* Consistency levels: strong, eventual.
* Isolation levels.
* CAP theorem: can’t have all three.

## 🧠 Step 4: Cache

* What is cache.
* Write policies: write-through, write-back, write-around.
* Replacement: LRU, LFU.
* CDNs: distribute content closer.

## 🌐 Step 5: Networking

* TCP vs UDP.
* HTTP/1,2,3 & HTTPS.
* WebSockets & WebRTC.

## 🏗 Step 6: Load Balancers

* Algorithms: round-robin, least connections.
* Consistent hashing.
* Proxy vs reverse proxy.
* Rate limiting.

## 📨 Step 7: Message Queues

* Asynchronous: Kafka, RabbitMQ.
* Pub/Sub model.

## 🧩 Step 8: Monoliths vs Microservices

* Why microservices.
* Single point of failure.
* Cascading failure.
* Containerization (Docker).
* Migration.

## 📊 Step 9: Monitoring & Logging

* Logging & metrics.
* Anomaly detection.

## 🔒 Step 10: Security

* Tokens, SSO, OAuth.
* ACLs, encryption.

## ⚖ Step 11: Trade-offs

* Push vs Pull.
* Consistency vs Availability.
* SQL vs NoSQL.
* Memory vs Latency.
* Throughput vs Latency.
* Accuracy vs Latency.

## 🛠 Step 12: Practice

* YouTube, Twitter, WhatsApp, Uber.
* Amazon, Dropbox, Netflix, Instagram.
* Zoom, Booking.com, Airbnb.
