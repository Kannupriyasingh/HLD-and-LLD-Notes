# ğŸŒŸ High-Level Design (HLD) â€” Short Notes

## ğŸªœ Step 1: Fundamentals

* Serverless vs Serverful: pay-per-use vs managed servers.
* Horizontal vs Vertical scaling.
* Threads: lightweight processes.
* Pages: fixed-size memory blocks.
* Internet: DNS â†’ TCP/UDP â†’ HTTP â†’ browser.

## ğŸ›¢ Step 2: Databases

* SQL vs NoSQL: ACID vs BASE.
* In-memory DBs: Redis, Memcached.
* Replication & migration.
* Partitioning & sharding.

## âš– Step 3: Consistency vs Availability

* Consistency levels: strong, eventual.
* Isolation levels.
* CAP theorem: canâ€™t have all three.

## ğŸ§  Step 4: Cache

* What is cache.
* Write policies: write-through, write-back, write-around.
* Replacement: LRU, LFU.
* CDNs: distribute content closer.

## ğŸŒ Step 5: Networking

* TCP vs UDP.
* HTTP/1,2,3 & HTTPS.
* WebSockets & WebRTC.

## ğŸ— Step 6: Load Balancers

* Algorithms: round-robin, least connections.
* Consistent hashing.
* Proxy vs reverse proxy.
* Rate limiting.

## ğŸ“¨ Step 7: Message Queues

* Asynchronous: Kafka, RabbitMQ.
* Pub/Sub model.

## ğŸ§© Step 8: Monoliths vs Microservices

* Why microservices.
* Single point of failure.
* Cascading failure.
* Containerization (Docker).
* Migration.

## ğŸ“Š Step 9: Monitoring & Logging

* Logging & metrics.
* Anomaly detection.

## ğŸ”’ Step 10: Security

* Tokens, SSO, OAuth.
* ACLs, encryption.

## âš– Step 11: Trade-offs

* Push vs Pull.
* Consistency vs Availability.
* SQL vs NoSQL.
* Memory vs Latency.
* Throughput vs Latency.
* Accuracy vs Latency.

## ğŸ›  Step 12: Practice

* YouTube, Twitter, WhatsApp, Uber.
* Amazon, Dropbox, Netflix, Instagram.
* Zoom, Booking.com, Airbnb.
